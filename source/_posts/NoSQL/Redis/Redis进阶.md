---
title: Redis进阶
date: 2022/7/13 20:46:25
tags:
- NoSQL
- Redis
categories:
- [NoSQL, Redis]
description: Redis进阶
---

# Redis进阶

## 启动方式

1. 默认启动：`redis-server`
2. 端口启动：`redis-server --port`
3. 配置文件启动：`redis-server redis-6379.conf`
4. `damonize`：守护进程方式启动
5. `logfile`：日志文件名

## 其他数据类型(略)

`Bitmaps`(操作`bit`位)，`Hyperloglog`(基数统计)，`GEO`(地图坐标点计算)

## Redis持久化

### 持久化保存什么

| 持久化方式 | 保存形式 |   存储   | 存储格式 |     关注点     |
| :--------: | :------: | :------: | :------: | :------------: |
|   `RDB`    |   快照   | 数据结果 |   简单   |    数据本身    |
|   `AOF`    |   日志   | 操作过程 |   复杂   | 数据的操作过程 |

### RDB启动方式(三种)

1. `save`：会阻塞当前 `Redis` 服务器，直到 `RDB` 过程完成为止，可能造成长时间阻塞，线上环境不建议使用
2. `bgsave`：手动启动，后台非即时执行，`Redis` 内部所有涉及 `RDB` 操作都采用 `bgsave` 的方式，调用 `fork` 函数生成子进程，不阻塞主线程，建议使用
3. `save second changes`：`Redis` 服务器发起指令，满足限定时间范围内 `key` 的变化数量达到指定数量即进行持久化
4. `RDB` 特殊方式启动
    1. 全量复制
    2. 服务器运行过程重启：`debug reload`
    3. 关闭服务器时保存指定数据：`shutdown save`，默认执行 `bgsave`，没有则执行 `AOF`

|   指令   | 读写 | 阻塞客户端指令 | 额外内存消耗 | 启动新线程 |
| :------: | :--: | :------------: | :----------: | :--------: |
|  `save`  | 同步 |       √        |      ×       |     ×      |
| `bgsave` | 异步 |       ×        |      √       |     √      |

### AOF启动方式

1. 以独立日志的方式记录每次写命令，重启时再重新执行 `AOF` 文件中命令达到恢复数据的目的
2. 相关配置
    1. `appendonly yes|no`：是否开启`AOF`，默认为不开启状态
    2. `appendfsync always|everysec|no`：`AOF`持久化数据策略
        1. `always`：每次写入操作均同步到`AOF`文件中，数据零误差，性能较低，不建议使用。
        2. `everysec`：每秒将缓冲区中的指令同步到`AOF`文件中，数据准确性较高，性能较高，建议使用
        3. `no`：由操作系统控制每次同步到 `AOF` 文件的周期，整体过程不可控
    3. `appendfilename filename`：`AOF` 持久化文件名，建议 `appendonly-端口号.aof`
3. `AOF ` 重写(命令不断写入  `AOF`，文件越来越大，引入 `AOF` 重写机制压缩文件体积
    1. 作用
        1. 将对同一个数据的若干个条命令执行结果转化成最终结果数据对应的指令进行记录
        2. 降低磁盘占用量，提高磁盘利用率
        3. 提高持久化效率，降低持久化写时间，提高`IO`性能
        4. 执行命令减少，降低数据恢复用时，提高数据恢复效率
    2. 重写规则
        1. 进程内已超时的数据（过期键）不再写入文件
        2. 忽略无效指令
        3. 对同一数据的多条写命令合并为一条命令 ，除 `String` 外类型，每条指令最多写入64个元素
    3. 重写方式
        1. 手动：`bgrewriteaof`指令
        2. 自动
            1. `auto-aof-rewrite-min-size size`：超过触发
            2. `auto-aof-rewrite-percentage percentage`：超过触发

![Image](https://img-1301279461.cos.ap-nanjing.myqcloud.com/img/Image-1622554314640.png)

![Image](https://img-1301279461.cos.ap-nanjing.myqcloud.com/img/Image-1622554323187.png)

### RDB优缺点

1. 优点
    1. `RDB` 是一个紧凑压缩的二进制文件，存储效率较高
    2. `RDB`内部存储的是 `Redis` 在某个时间点的数据快照，适合数据备份，全量复制
    3. `RDB` 恢复数据的速度要比 `AOF` 快很多
    4. 应用：服务器中每 `X` 小时执行 `bgsave` 备份，并将 `RDB` 文件拷贝到远程机器中，用于灾难恢复
2. 缺点
    1. `RDB` 方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据
    2. `bgsave` 指令每次运行要执行 `fork` 操作创建子进程，要牺牲掉一些性能
    3. `Redis` 的众多版本中未进行 `RDB` 文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象

| 持久化方式 |     占用存储     | 存储速度 | 恢复速度 |       数据安全性       |  资源消耗  | 启动优先级 |
| :--------: | :--------------: | :------: | :------: | :--------------------: | :--------: | :--------: |
|   `RDB`    | 小(数据级：压缩) |    慢    |    快    | 会丢失数据(时间点快照) | 高(重量级) |     低     |
|   `AOF`    | 大(指令级：重写) |    快    |    慢    |      依据策略决定      | 低(轻量级) |     高     |

## Redis事务

1. 事务操作
    1. 开启：`multi`
    2. 提交：`exec`
    3. 回滚：`discard`
2. 指令
    1. 事务开启后的指令，如果语法错误，所有命令都不执行
    2. 格式正确但是没有对应操作，其他指令正常执行
3. 开启事务后：指令都放入队列中，`exec` 执行后命令才开始执行
4. 锁机制
    1. 乐观锁（开启事务的情况下）
        1. 上锁：`watch key1 [key2]`
        2. 取消锁：`unwatch`，对应 `key` 发生变化，指令不执行
    2. 分布式锁(悲观)
        1. 上锁：`setnx lock-key value`，`key ` 要锁的 `key`，`lock-key  ` 本身也是 `key`
        2. 取消锁：`del lock-key`
        3. 分布式锁防止死锁：添加过期时间
            1. 设置秒：`expire lock-key second`
            2. 设置毫秒：`pexpire lock-key milliseconds`

## Redis的key删除策略

### 过期数据(数据删除策略)

1. 定时删除：创建一个定时器，`key`过期就删除，节约内存，无占用，占用 `CPU` 资源，频度高，拿时间换空间
2. 惰性删除：`get key`发现 `key` 过期才删除，内存占用严重，延时执行，`CPU` 利用率高，拿空间换时间
3. 定期删除：随机抽查不同库中`w`个`key`，删除 `key>w*0.25` 重点抽查该库到删除 `key<w*0.25`，定期随机清理，每秒花费固定的`CPU`资源维护内存，重点抽查

### 逐出算法

1. 当不存在过期的 `key`，或者根本没有过期 `key`，内存不够用怎么办？
2. 相关配置
    1. 最大内存：`maxmemory`，占物理内存比例
    2. 每次选取待删除`key`个数：`maxmemory-samples`
    3. 删除策略：配置文件`maxmemory-policy`，下面是属性值
        1. 检测易失数据：设有有效时间的`key`
            1. `volatile-lru`：`least-recent-use`(最长时间未访问的`key`)挑选最近最少使用的数据淘汰
            2. `volatile-lfu`：`lease frequently-use`，挑选最近使用次数最少的数据淘汰
            3. `volatile-ttl`：挑选将要过期的数据淘汰
            4. `volatile-random`：任意选择数据淘汰
        2. 检测全库数据
            1. `allkeys-lru`：挑选最近最少使用的数据淘汰
            2. `allkeys-lfu`：挑选最近使用次数最少的数据淘汰
            3. `allkeys-random`：任意选择数据淘汰
        3. 放弃数据驱除：`no-enviction`（驱逐）：禁止驱逐数据4.0默认策略，会引发错误`OOM`

