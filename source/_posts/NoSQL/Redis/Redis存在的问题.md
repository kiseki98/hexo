---
title: Redis存在的问题
date: 2022/7/13 20:46:25
tags:
- NoSQL
- Redis
categories:
- [NoSQL, Redis]
description: Redis存在的问题
---

# Redis常见问题

## 缓存预热

1. 准备
    1. 将统计结果中的数据分类，根据级别，`Redis`优先加载级别较高的热点数据
    2. 利用分布式多服务器同时进行数据读取，提速数据加载过程
    3. 热点数据主从同时预热
2. 实施
    1. 使用脚本程序固定触发数据预热过程
    2. 如果条件允许，使用了`CDN`内容分发网络，效果会更好
3. 总结
    1. 缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统
    2. 避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

## 缓存雪崩

1. 问题分析：在一个较短的时间内，缓存中较多的`key`集中过期，`Redis`未命中压力转移到数据库，数据库崩溃，缓存无数据可用，`Redis`服务器资源被严重占用，`Redis`集群呈现崩塌，服务器无法处理请求，服务器崩溃
2. 解决方案(道)：页面静态化，多级缓存架构，限流，降级
3. 解决方案(术)：`LRU`和`LFU`切换，`key`过期时间采用固定时间+随机值，超热数据使用永久`key`，加锁(慎用)
4. 总结：
    1. 缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现（约40%）
    2. 配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。

## 缓存击穿（redis不存在数据库存在）

1. 问题分析：单个`key`热度过高，`Redis`中某个`key`过期，该`key`访问量巨大，多个数据请求从服务器直接压到`Redis`后，均未命中，`Redis`在短时间内发起了大量对数据库中同一数据的访问
2. 解决方案(术)：加大`key`的过期时间，监控访问量，访问激增的`key`延长有效期或设置永久，设置二级缓存，保证不同时淘汰。**加锁**(慎用)
3. 总结：
    1. 缓存击穿是单个高热数据过期的瞬间，数据访问量较大，未命中`Redis`后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力
    2. 应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个`key`的过期监控难度较高，配合雪崩处理策略即可

## 缓存穿透（redis不存在数据库也不存在）

1. 问题分析：`Redis`中大面积出现未命中，出现非正常`URL`访问(黑客访问本身就不存在的`key`)，数据库中也不存在
2. 解决方案：缓存`null`，白名单策略，实施监控，`key `加密
3. 总结：缓存击穿访问了不存在的数据，跳过了合法数据的 `Redis` 数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值。应对策略应该在临时预案防范方面多做文章

## 双写一致性

# Spring操作Redis

## 五种数据类型

1. `String`：等同于`Map<String,String>`
2. `List`：等同于`Map<String,List<String>>`
3. `Set`：等同于`Map<String,Set<String>>`
4. `Zset`：等同于`Map<String,SortSet<String>>`，排序的set
5. `Hash`：等同于`Map<String，Map<String,String>>`

## Spring操作五种数据类型

```java
// 下面操作后面跟上set()\get()
redisTemplate.opsForValue(); // 操作String
redisTemplate.opsForHash();	// 操作Hash
redisTemplate.boundHashOps(key).put(key, value); // 实际常用操作Hash
redisTemplate.opsForList(); // 操作List
redisTemplate.opsForSet(); // 操作Set
redisTemplate.opsForZSet(); // 操作ZSet
```