---
title: JVM内存结构
date: 2022/7/18 10:46:25
tags:
- Java
- JVM
- JVM内存结构
categories:
- [Java, JVM]
description: JVM内存结构
---

# 程序计数器(Program Counter Register)

## JVM指令

不能被 `CPU` 直接执行，需要解释器解释为**机器码**，而**解释器**需要从程序计数器中拿到下一条 `JVM` 指令的地址

## 作用

记住下一条 `JVM  ` 指令地址，寄存器是 `CPU` 中读取速度最快的单元

## 原理

1. 从字节码的执行原理来看，单线程的情况下程序计数器是可有可无的（可以记住指令执行到的位置，多线程无法判断是哪个线程了）
2. 但是现实中程序往往是多线程协作完成任务的。`JVM ` 的多线程是通过 `CPU   ` 时间片轮转来实现的，某个线程在执行的过程中可能会因为时间片耗尽而挂起。当它再次获取时间片时，需要从挂起的地方继续执行。
3. 在 `JVM` 中，通过程序计数器来记录程序的字节码执行位置。程序计数器具有线程隔离性，每个线程拥有自己的程序计数器。

## 特点

1. 线程私有，通过寄存器实现每个线程都有自己的计数器，与线程共存亡
2. 内存中唯一一个不会出现内存溢出的区域
3. 占据内存特别小

# 虚拟机栈(Java Virtual Machine Stacks java)

线程私有（先进后出，线程运行需要的内存空间）

## 定义

1. **栈**是每个线程运行时所需要的**内存空间**
2. 每个栈由多个**栈帧**组成，对应着该线程调用**方法占用的内存**
3. 栈帧组成：**操作数栈，局部变量表**
4. 每个线程都只有一个**活动栈帧**（顶部栈帧），对应着线程当前执行的**方法**。

## 问题

### 垃圾回收是否涉及到栈内存？

**答：** **不会涉及**。因为栈对应着一个程序的执行过程，在执行过程中，活动栈不断随着该方法的运行结束而弹出，直到程序执行完成，栈为空，消失。即一个进程执行完毕，线程栈消失。

### 栈内存越大越好吗？

不是。服务器物理内存是固定的，若栈内存越大，则能够同时运行的线程数量就会减小。栈是由多个栈帧组成，内存增大，只是将可以容纳栈帧的数量增多，除了可**以调用更多的方法(递归)**，没有其他的作用。`-Xss` 设置栈内存大小，一般 `-Xss=1M`

### 方法的局部变量是否线程安全？

 不一定。方法内的局部变量且没有逃离方法的作用范围时（不作为**方法参数**或者**方法返回值**），是线程安全的。如果局部变量引用了对象，由于对象存在于堆中，一般其他线程可以访问修改，需要考虑线程安全。

## 栈内存溢出

1. 栈帧过**多**导致内存溢出，一直调用方法。只有栈帧入栈，没有出栈（方法的递归调用，没设置正确的结束条件）
2. 栈帧过**大**导致内存溢出（交叉引用），比如A对象包含属性B对象，B对象属性有A对象。利用 `ObjectMapper` 转换对象为 `String` 出现这个问题

### 线程运行诊断

1. **案例1: cpu 占用过多**
2. **案例2**：迟迟得不到结果（死锁）：两个线程等待对方的锁

```java
public class Demo {
    static A a = new A();static B b = new B();
    public static void main(String[] args) {//两个线程相互拿到对方所需的一个对象
        new Thread(()->{
            synchronized (a){//拿到a睡2秒
                Thread.sleep(2000);
            }//拿不到b，b一秒时被另一个线程拿走了。自己睡了2秒
            synchronized (b){
                System.out.println("获得a，未获得b");
            }
        }).start();
       Thread.sleep(1000);//睡一秒，保证线程先后顺序
        new Thread(()->{
            synchronized (b){
               synchronized (a){
                System.out.println("获得b，未获得a");
            }
        }).start();
    }
}
```

![批注 2020-04-01 225521](https://img-1301279461.cos.ap-nanjing.myqcloud.com/img/%E6%89%B9%E6%B3%A8-2020-04-01-225521.png)每个方法执行完毕，栈帧的内存空间会被释放，顶部为活动栈帧

# 本地方法栈(Native Method Stack)

1. 本地方法（`Native Method`）：不是由 `JAVA` 编写的方法，`JAVA `语言有很多的限制，有些功能不能直接和系统底层打交道（需要 `C` 或者 `c++` 写的本地方法），`JAVA` 代码可以通过本地方法调用更底层功能。本地方法有 `native` 修饰
2. 定义：这些本地方法使用的内存就叫本地方法栈（给本地方法提供内存空间）
3. **特点**：
   1. **线程私有**，生命周期随着线程
   2. **与虚拟机栈区别**
      1. 本地方法栈服务的对象是 `JVM` 运行的 `native ` 方法
      2. 虚拟机栈服务的是 `JVM` 执行的 `JAVA` 方法。

# 堆(Heap)

## 定义

通过 `new` 关键字创建的对象，存放的内存空间。

## 特点

1. 通过 `new` 关键字创建的对象都会使用堆内存
2. 线程共享，堆中的对象都存在线程安全的问题
3. 垃圾回收机制重点区域。

## 堆内存溢出

`new` 关键字创建的对象保存在堆内存中（一般在堆的 `Eden` 这个区），对象得不到释放，占用内存一直增加，就出现内存溢出

## off-heap(堆外内存)

1. 属于：`JVM` 进程管理的内存，不受垃圾回收影响
2. `off-heap`叫做堆外内存（直接内存），将你的对象从堆中脱离出来序列化，存储内存中。它们必须首先反序列化才能使用，也不受垃圾收集。
3. 序列化和反序列化将会影响部分性能（所以可以考虑使用 `FST-serialization` ）使用堆外内存能够降低 `GC` 导致的暂停。

## JNI（Java Native Interface）

### 作用

1. `JNI` 是 `Java Native Interface` 的缩写，它提供了若干的API实现与其他语言的交互，主要是 `C` 和 `C++`
2. 从 `Java1.1` 开始，`JNI `标准成为 `Java` 平台的一部分，它允许`Java`代码和其他语言写的代码进行交互。
3. `JNI ` 一开始是为了本地已编译语言，尤其是C和C++而设计的，但是它并不妨碍你使用其他编程语言，只要调用约定受支持就可以了。
4. 使用 `Java` 与本地已编译的代码交互，通常会丧失平台可移植性。但是，有些情况下这样做是可以接受的，甚至是必须的。例如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。`JNI` 标准至少要保证本地代码能工作在任何 `JVM` 环境。
5. 使用 `JNI` 交互 `Java` 和 其他语言，由于 `JVM` 的存在 `GC` 导致数据地址变化（标记整理和复制算法）产生异常，`JNI` 应当使用直接内存

## 堆内存诊断

### 诊断工具

1. `jps`：查看当前系统有哪些 `JAVA` 进程（`jps`命令查看当前`JAVA`进程）
2. `jmap`：查看某`JAVA`进程堆内存占用情况（`jmap -heap JAVA进程id` ）
3. `jconsole`：图形界面，多功能检测工具 ，可连续监测

### 诊断案例(垃圾回收后内存占用依然很高)

1. 更好用的一个工具：`jvisualvm`（命令，可视化展示虚拟机）
2. 通过堆转储功能 `dump`，找到堆内存占用最大的对象（ `dump` 之后点击查找，默认找到占用最大的前20个对象）

# 方法区(Method Area)线程共享

## 定义

所有 `JAVA` 虚拟机线程共享的，存储类 `class` 相关的结构信息和运行时常量池，`filed` 成员变量，`method data` 方法数据，成员方法和构造方法的代码(方法区逻辑上是 `heap` 堆的组成部分)

## 创建时间

虚拟机启动时创建

## 内存溢出

方法区内存加载类过多导致的内存溢出

## 组成与实现

 `JDK6`（永久代实现）和  `JDK8`（元空间实现）中方法区的区别，其中最主要的区别是8中将方法区转移到本地内存中，且常量池分为运行时常量池和字符串常量池.且字符串常量池被留在内存中的堆中。

![Image](https://img-1301279461.cos.ap-nanjing.myqcloud.com/img/Image.png)

## 运行时常量池(属于方法区)

1. 常量池的定义
   1. 定义：常量池表，虚拟机指令根据这张常量表找到要执行的**类名**，**方法名**，**参数类型**，**字面量**等信息
   2. 二进制字节码（类基本信息，常量池，类方法定义，包含虚拟机指令）
   3. 通过`javap -v *.class`命令查看字节码文件中的常量池
   4. 作用：存放了编译时期生成的各种字面量和符号引用
3. 运行时常量池
   1. `JVM ` 在执行某个类的时候，必须经过**加载**、**连接(验证、准备、解析三个阶段)**、**初始化**
   2. 当类加载到内存中后，`JVM` 就会将 `class` 常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个
   3. `class` 常量池中存的是符号引用值。而经过解析 `resolve` 之后，也就是把符号引用替换为直接引用，解析的过程会去查询`StringTable`，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的

## StringTable

1. 垃圾回收：受垃圾回收机制管理(堆内存中)
2. `StringTable` 是 `HashTable` 结构，不能扩容
3. 性能调优(`StringTable` 底层是 `HashTable`，`Hash  `表性能与大小密切相关)
   1. 设置桶 `buckets` 的数量增大，桶的数量越少，`Hash ` 冲突概率越大，耗时更多！
   2. 调整`Hash`表中桶子个数，`-XX:StringTableSize=桶个数`
   3. 考虑字符串是否入池，字符对象在堆内存中十分占用空间，如果入串池，不会有重复的可以节省空间
4. 特点
   1. 懒加载：常量池中的信息都被加载到运行时常量池，这时 `a、b、ab`都是常量池中的符号，还没变为 `JAVA` 字符串对象！
   2. 存入条件
      1. 直接使用双引号声明出来的 `String` 对象会直接存储在常量池中。拼接的字符串常量`"a"+"b"`也保存在串池中，相当于`"ab"`。这其实是`JAVA`编译器的优化。确定多个常量字符串拼接结果还是常量
      2. 调用字符串对象的`intern()`方法，如`String s6=s4.intern()`,尝试把s4的值**放入**串池中（1.8版本）
      3. 返回串池对象的引用：不管是否存在`s4`相同的值，这个方法都会返回值在串池的地址引用，把串池中相同的值的引用返回给`s6`
      4. 不影响s4的引用
         1. 串池存在`s4`相同的值：`s4`引用不变，还是指向堆内存
         2. 串池不存在`s4`相同的值，`s4`引用不变，`s4`的引用放入串池(串池存对象也存引用)

```java
// 1.6相当于两个对象，intern方法不影响s4的地址引用（1.8才影响）
// 主要解决问题：需要弄清楚引用指向字符串常量池还是堆内存！！！new 出来的字符串对象存放到堆内存中！引用地址不一样
public class StringTable {
    public static void main(String[] args) {
        String s1 = "a";
        String s2 = "b";
        //javac在编译器优化，这是两个字符串常量拼接，结果是固定的，直接在编译器确定为ab，放入字符串常池中，并且引用字符串常量池中的地址
        String s3 = "a"+"b";
        //变量拼接，背后执行new StringBuilder().append("a").append("b").toString();相当于new String("ab")，存放在堆内存中！
        String s4 = s1+s2;
        //尝试放入字符串常量池中，发现ab已存在，s5直接引用字符串常量池中的地址
        String s5 = "ab";
        //尝试把s4的值放入字符串常量池中，如果不存在，则放入，且s4的引用指向放入串池之后的地址！如果已经有了s4的地址引用还是堆内存地址
        String s6 = s4.intern();
        //分析：字符串常量都会尝试放入串池中，懒加载机制（执行一行代码,加载一行，放入串池）
        System.out.println(s4 == s5); // false
        System.out.println(s3 == s4); // false
        System.out.println(s3 == s5); // true
        System.out.println(s3 == s6); // true
        {
            String x2 = new String("c") + new String("d");// new了对象
            // intern相当于把对象尝试放入串池中，串池中不存在该对象的值，x2的引用指向串池
            x2.intern(); // 把x2的地址放入串池中 x2地址不变
            String x1="cd";
            System.out.println(x1 == x2); // true
        }
        {
            // x2相当于new string（"cd"），new对象，存入堆内存
            String x2 = new String("c") + new String("d");//new了对象
            String x1="cd";
            // intern相当于把对象尝试放入串池中，串池中存在该对象的值，x2的引用指向还是堆内存
            x2.intern(); // 把x2放入串池中 x2地址不变，串池中已有cd，
            System.out.println(x1 == x2); // false
        }
    }
}
```

# 直接内存(Direct Memery)

## 特点

1. 常见于`NIO`操作时，用于数据的缓冲区
2. 分配回收成本高，但读写性能高
3. 不受`JVM`内存回收管理（存在**内存溢出**问题）

## 直接内存使用前后

### 使用前

1. 因为 `JAVA` 无法操作本地文件，在 `JAVA` 堆内存中划出缓冲区
2. 从用户态转移到内核态，本地方法在系统内存中划出一段系统缓冲区，将磁盘文件分部分缓冲到系统缓冲区中，间接的将系统缓冲区中数据传输到 `JAVA` 缓冲区中
3. 内核态转到用户态，调用输出流写入操作，将文件 `copy` 到另一个位置，循环 `copy`，直到全部复制完成

![Image](https://img-1301279461.cos.ap-nanjing.myqcloud.com/img/Image-1621854494407.png)

### 使用后

1. `ByteBuffer.allocateDirect(_size)`，在系统内存中分配直接内存
2. 系统方法和`JAVA`方法都可以访问直接内存；
3. 与不使用直接内存相比，减少了一次从系统缓存区向`JAVA`缓冲区复制的操作，复制效率成倍上升

![Image](https://img-1301279461.cos.ap-nanjing.myqcloud.com/img/Image-1621854500532.png)

## 分配和回收原理

1. 使用 `Unsafe` 对象的方法实现直接内存的分配回收，回收主要使用的是`freeMemory()`
2. `ByteBuffer` 类内部，使用了 `Cleaner`（虚引用）来检测关联的 `ByteBuffer` 对象，一旦 `ByteBuffer` 对象被回收（不能使用 `ByteBuffer` 对象释放直接内存），就会由 `ReferenceHandler` （这是个守护线程）线程通过 `Cleaner` 的 `clean` 对象调用 `freeMenory()` 来释放直接内存。
3. `-XX:+DisableExplicitGC` （虚拟机设置参数）显式的`System.gc()`（方法不起作用）显式的垃圾回收 `FULL GC`，被禁用。
4. 因为考虑到系统性能，`FULL GC`时间够长，会严重影响性能。所以涉及到直接内存的使用，释放内存使用`Unsafe.freeMemory`，不建议使用`System.gc()`。