---
title: MySQL的锁
date: 2022/5/13 20:46:25
tags:
- MySQL
- 数据库锁
categories:
- [MySQL, 锁]
description: MySQL的锁简介
---

# 锁

## 锁的分类

1. 宏观
   1. 数据库锁：粒度小，方便用于集群环境
   2. 代码锁：力度大（大于等于数据库锁），需要自己封装实现（ORM框架）
2. 按粒度区分（以InnoDB）
   1. 表锁：
   2. 行锁：只有明确指定索引，才会执行行锁，否则执行表锁
3. 按数据操作区分
   2. 共享锁：也叫做 S 锁，允许事务读取一行数据，兼容读锁但不兼容写锁
   3. 排它锁：也叫做 X 锁，允许事务删除或更新一行数据，不兼容读锁和写锁，其它锁均阻塞

## 快照读和当前读
通过加锁可以解决一些并发问题，MySQL中根据操作是否加锁有快照读和当前读两个概念：

1. 快照读：读取记录数据的可见版本
   1. 不加锁
   2. 普通的SELECT语句都是快照读
2. 当前读：读取记录数据的最新版本
   1. 显式加锁(FOR UPDATE、LOCK IN SHARE MODE)的是当前读
   2. 更新操作(INSERT、UPDATE、DELETE)也是当前读，会加锁

> 所以，当一个事务在更新一行数据时，其它事务就不能对这行数据进行操作，只有等当前事务提交并释放锁之后其它事务才能读取或修改，也就避免了数据库层面的丢失修改问题
> 基于此机制，即使是读未提交级别也能避免丢失修改问题。
> 通过显式加锁(FOR UPDATE、LOCK IN SHARE MODE)也可以避免脏读问题

## MVCC多版本并发控制 
> MVCC即多版本并发控制，每个数据都有多个版本，MySQL通过MVCC来实现读已提交和可重复读隔离级别，可以避免脏读和不可重复读问题
> 首先说说MVCC的流程：当一个事务读一个数据时，会比较数据的版本，判断该数据是否对自己可见，如果不可见则通过read view和undo log回滚版本，直到找到对自己可见的数据版本

要理解MVCC的具体实现，需要理解涉及的一些底层原理：

1. 事务版本号：每个事务都有自己的ID，用于判断先后顺序
2. undo log：回滚日志，一种逻辑日志
3. 隐式字段：每个数据记录都有隐式字段 
   1. trx_id：记录操作这个数据的事务ID 
   2. roll_pointer：指向回滚段的undo日志 
   3. row_id(没有主键和非NULL唯一键时才有，是单调递增的行ID)
4. read_view：一致性视图，基于整库的快照 
   1. m_ids：系统中活跃的事务(即未提交的事务)ID，是一个list 
   2. min_limit_id： m_ids中最小的ID 
   3. max_limit_id： m_ids中最大ID+1 
   4. create_trx_id：创建当前read view的事务ID，即当前事务的ID

**如何判断数据是否可见？**

通过比较trx_id & min_limit_id & max_limit_id来判断，具体：
1. trx_id < min_limit_id：说明操作这个版本的事务已经提交，可见 
2. trx_id >= max_limit_id：说明操作这个版本的事务在生成read view之后才开启，不可见 
3. min_limit_id < trx_id <max_limit_id ： 
   1. 若trx_id不在m_ids中，说明操作这个版本的事务已经提交，可见； 
   2. 若trx_id在m_ids且不等于create_trx_id：说明操作这个版本的事务还未提交，且不是当前事务，不可见


**你可能要问了，为什么MVCC不仅能实现可重复读，还能实现已提交读呢？两种隔离级别下MVCC的实现有什么区别？** 

这是因为MVCC在RR(可重复读)和RC(读已提交)下生成read view的时机不同：
1. RR：事务开始时创建read view，之后事务里的查询都用这个一致性视图
2. RC：每一个语句执行前都创建一个read view

> 注意一点，可重复读隔离级别下，普通的SELECT操作是快照读，但如果要更新数据，那就不能根据数据的历史版本来了，会造成丢失修改，所以不可重复读中两次读到的数据不一样指的是在自己没有操作的情况下，因为别的事务修改导致的不一样，如果自己在事务中进行了UPDATE，是当前读，根据最新的版本进行，之后再读到的就是自己修改后的新数据了。

## 锁算法：以InnoDB的RR隔离级别
无锁： id不存在，不会执行任何锁操作
```sql
select * from user where id = -1 for update;
```

行锁：指定一个明确的主键
```sql
select * from user where id = 3 for update;
```

表锁：主键（索引）不明确
```sql
select * from user where name = 'kkk' for update;

select * from user where id <> 2 for update;
```

1. 行锁算法
   1. 普通行锁算法 Record Lock
      1. 记录的键值在条件范围内
      2. 记录存在
   2. 间隙锁算法 Gap Lock
      1. 对于条件范围内不存在的键值，叫做 Gap
   3. 行锁算法 Next-Key Lock
      1. 行 & 间隙
      2. 条件范围内部分记录存在（id只有50）
      3. 例如： `select * from user where id > 49 and id < 60 for update;`
2. 表锁算法：
   1. 意向锁：当一个事务带着表锁去访问一个被加了行锁的资源
   2. 自增锁:

# 老的内容
## 手动上锁

1. 手动添加表锁：`lock table table1 read(write) ，table2 read(write)`，可以同时加多个（读/写锁）
2. 检查表是否被锁：`show open tables`
3. 释放表锁：`unlock tables`释放当前session持有的任何锁

## 存储引擎的锁

### MyISAM表锁

**开始事务**：下面两种锁都假设用户A先获得表锁

#### 读锁(共享锁)

| 用户\操作 | 读取表 |            修改表             | 读取(修改)没锁定的表 |
| :-------: | :----: | :---------------------------: | :------------------: |
|   用户A   |   √    |               ×               |          ×           |
|   用户B   |   √    | 阻塞，必须等待A释放锁才能修改 |          √           |

#### 写锁(排它锁)

| 用户\操作 |            读取表             |            修改表             | 读取(修改)没锁定的表 |
| :-------: | :---------------------------: | :---------------------------: | :------------------: |
|   用户A   |               √               |               √               |          ×           |
|   用户B   | 阻塞，必须等待A释放锁才能查询 | 阻塞，必须等待A释放锁才能查询 |          √           |

#### 案例结论

`MyISAM`在执行查询语句`SELECT`之前会自动给所涉及的表加上读锁，在执行增删改前自动给设计的表加上写锁

`MySQL`的表级锁有两种模式：表共享读锁(`TABLE READ LOCK`)，表独占写锁(`TABLE WRITE LOCK`)

| 锁类型 | 可否兼容 | 读锁 | 写锁 |
| :----: | :------: | :--: | :--: |
|  读锁  |    是    |  是  |  否  |
|  写锁  |    是    |  否  |  否  |

结论：结合上表对MyISAM表进行操作会有以下情况(简而言之：**读锁阻塞只阻塞写，写锁阻塞读和写**)

1. 对`MyISAM`表读操作(读锁)：不会堵塞其他进程对同一表的**读**请求，但会阻塞**写**请求，等待锁释放之后才执行其他进程的**写**请求
2. 对`MyISAM`表写操作(写锁)：会堵塞其他进程对同一表的**读/写**请求，等待锁释放之后才执行其他进程的**读/写**请求
3. `MyISAM`不适合做写的引擎：读写锁的**优先级**是**写**更高，获得写锁之后其他进程阻塞不能操作，大量更新使查询得不到表锁导致一直阻塞
4. 快速分析表锁定：
   1. `SQL`：`show status like 'table'`
   2. `Table_locks_immediate`：产生表级锁定的次数
   3. `Table_locks_waited`：出现表级锁定争用导致等待(阻塞)的次数

### InnoDB

开始事务：关闭自动提交，假设用户A先操作

在AB两个用户都在操作同一行时，A先修改，B想修改（进入阻塞，A只有`commit`，B才能修改）

事务：相当于不同事务都把表复制给自己（不直接操作原表）！没有提交的时候，都只能看到自己修改的（隔离性）！只有提交之后，才会把修改的地方修改给原表！虽然事务隔离！但是操作像同一行时或其中一个用户导致索引失效时，另一个会进入阻塞（前者行锁，后者索引失效导致变成表锁）

**如何锁定一行**：`commit`之后锁定释放

```sql
SELECT * FROM TABLE1 WHERE no = 1 FOR UPDATE
```

| 用户\操作 | 关闭自动提交 | 操作不同行 | 操作同行 | A操作完  |           索引失效            |
| :-------: | :----------: | :--------: | :------: | :------: | :---------------------------: |
|   用户A   |      是      |    可以    |  先操作  |  A提交   |       A操作存在隐式转换       |
|   用户B   |      是      |    可以    | 进入阻塞 | 解除阻塞 | B修改不同行(阻塞，行锁变表锁) |

结论：

1. 数据里事务隔离越严格，并发副作用越少，代价越大，相当于一定程度的“串行化”，和“并发”显然矛盾
2. 行锁优劣势
   1. 优势：实现行级锁定，虽然锁定机制实现带来的性能损耗可能比表级锁高，但整体并发能力要高于`MyISAM`，并发较高的时候`InnoDB`整体性能明显高于`MyISAM`
   2. 劣势：使用不当时(隐式转换索引失效)，行级锁变表级锁，`InnoDB`整体性能可能比`MyISAM`更差
3. 间隙锁(`NEXT-KEY`锁)
   1. 什么是间隙锁：当我们检索条件不是相等条件检索数据，并请求读锁或者写锁，InnoDB会给符合条件的已有数据记录的索引项加锁，对于值在条件范围内但不存在的记录，叫间隙锁
   2. 危害：导致无法插入锁定范围内的任何数据(锁定，阻塞了)
4. 分析行锁
   1. `SQL`：`show status like 'innodb_row_lock%'`
   2. `innodb_row_lock_current_waits`：当前正在等待锁定的数量
   3. `innodb_row_lock_time`：从系统启动到现在锁定总时长
   4. `innodb_row_lock_time_avg`：每次等待锁花平均时间
   5. `innodb_row_lock_time_max`：从系统启动到现在最长等待的时间
   6. `innodb_row_lock_waits`：从系统启动到现在等待多少次
   
### 封锁技术

封锁技术可以避免一些并发操作引起的不一致错误，但也会产生其他的一些问题

1. 活锁：如果某个事务处在永远等待的状态，得不到封锁的机会，这种现象为活锁，最好的方法就是采用先来先服务的策略。
2. 死锁：两个或两个以上的事务都处于等待状态每个事务都在等待对方事务结束封锁，它才能执行下去，这样任何事务都处于等待状态无法继续执行的现象称为死锁
3. 解决死锁问题方法有两类：
   1. 死锁的预防
   2. 死锁的诊断与预防