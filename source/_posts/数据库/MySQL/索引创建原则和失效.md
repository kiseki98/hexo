# 索引创建原则

1. 索引创建原则
   1. 频繁作为查询条件的字段应该创建索引
   2. 查询中与其他表关联的字段，外键关系建立索引
   3. 查询中分组或者统计的字段
   4. 排序字段，通过索引提高排序速度
2. 不创建索引原则
   1. 频繁更新的字段不适合创建索引(更新数据同时更新索引，增加 `IO ` 负担)
   2. `WHERE ` 条件或者排序用不到的字段
   3. 表记录太少
   4. 经常增删改查的表(更新数据同时更新索引，增加 `IO` 负担)
   5. 数据重复且平均分布的表字段，为最常查询的字段建立索引
3. 创建索引(连接查询，索引加反边，左连接加右，右连接加左。不动索引，连接调换位置达成索引的使用)
   1. 复合索引：离散度大的放在前面
   2. 常用作查询条件的：放在复合索引左端(最左前缀法则)
   3. 使用短索引：对字符串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个`CHAR(255)`的 列，如果在前`10` 个或`20` 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和 `I/O` 操作。
4. **最左前缀**：查询条件从最左列开始且不跳过索引中的列

# 索引失效

1. 不在索引列上做任何操作(计算、函数、自动/手动类型转换)，会导致索引失效全表扫描，字符串不加单引号索引失效(隐式类型转换)，`MySQL`会自动进行类型转换
2. 复合索引进行范围查询右边的索引列失效(部分生效)，`LIKE`以常量`sa%`开头全部生效
3. 尽量使用覆盖索引(索引列和查询列一致)，减少使用`SELECT *` 
4. `MySQL`使用不等于 `<>` 或者 `!=` 的时候无法使用索引导致全表扫描
5. `IS NULL、IS NOT NULL`也无法使用索引
6. `LIKE` 以通配符 `%abc` 开头，索引失效导致全表扫描，如果使用**覆盖索引**则索引可以生效
7. 少用 `OR`，用它连接索引会失效，导致全表扫描
8. `NOT IN` 操作不会使用索引，导致全表扫描可以使用 `NOT EXIST` 替代
9. 复合索引只要有一列包含 `NULL`，这一列索引失效
10. 覆盖索引 `WHERE` 条件全是 `AND` 连接忽略顺序！不需要和覆盖索引完全一致（`where ` 条件常量情况下）。`where a=1 and b=2 and d>4 and c =3`，索引全生效！
11. 对于 `ORDER BY`中，与索引顺序不一样，排序索引失效！（有一个特例，`ORDER BY`中没按顺序，c，b排序如果此时查询条件`WHERE b=2`，对于`ORDER BY`没影响，因为排序字段个常量）
12. `MySQL` 查询只使用一个索引(非复合索引)，因此如果 `WHERE` 子句中已经使用了索引的话，那么 `ORDER BY` 中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。
13. `OR` 改写为 `IN` (`OR`的效率是`N`级别)，`OR` 改写为 `UNION` (`MySQL`的索引合并很弱智)。
14. `LIMIT` 高效分页(`LIMIT`越大，效率越低)，建议使用 `WHERE` 代替
15. 使用 `UNION ALL` 替代 `UNION` (有去重开销)
16. 少用连接 `JOIN`
17. 使用 `GROUP BY`，少用 `DISTINCT`
18. 请使用同类型比较：面试题讲解：`GROUP BY` 基本都要排序，会有临时表产生

![image-20210518170855490](https://img-1301279461.cos.ap-nanjing.myqcloud.com/img/image-20210518170855490-1621328936987.png)

![image-20210518170931864](https://img-1301279461.cos.ap-nanjing.myqcloud.com/img/image-20210518170931864.png)
